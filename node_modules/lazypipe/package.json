{
  "name": "lazypipe",
  "description": "Use to create an immutable, lazily initialized pipeline from a series of streams.",
  "version": "0.2.4",
  "homepage": "https://github.com/OverZealous/lazypipe",
  "repository": {
    "type": "git",
    "url": "git://github.com/OverZealous/lazypipe.git"
  },
  "bugs": {
    "url": "https://github.com/OverZealous/lazypipe/issues"
  },
  "author": {
    "name": "Phil DeJarnett",
    "url": "http://overzealous.com/"
  },
  "main": "./index.js",
  "keywords": [
    "gulpfriendly",
    "stream",
    "streams",
    "combine",
    "lazy",
    "pipeline",
    "gulp"
  ],
  "dependencies": {
    "stream-combiner": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "event-stream": "~3.1.0"
  },
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "mocha --reporter spec"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "licenses": "MIT",
  "readme": "# lazypipe\r\n\r\n[![NPM version][npm-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Support via Gratipay][gratipay-image]][gratipay-url]\r\n\r\nLazypipe allows you to create an immutable, lazily-initialized pipeline.  It's designed to be used in an environment where you want to reuse partial pipelines, such as with [gulp](http://gulpjs.com).\r\n\r\nThis module returns a function that can be used to start building a lazypipe.  Individual steps are added via the `.pipe()` method.  At any point, a new lazypipe can be built by adding to an existing one, without affecting the previous lazypipe.  Lazypipes can even be used as steps within another lazypipe.\r\n\r\nOnce the partial pipeline is ready to use, call the last result from `.pipe()` directly as a function (e.g.: `.pipe()()`).\r\n\r\n## Usage\r\n\r\nInstall using:\r\n\r\n    npm i --save-dev lazypipe\r\n\r\nThen create lazypipes like so:\r\n\r\n```js\r\n// Example usage within a gulpfile\r\nvar lazypipe = require('lazypipe');\r\n\r\n...\r\n\r\n// initialize a lazypipe\r\nvar jsHintTasks = lazypipe()\r\n    // adding a pipeline step, notice the stream function has not been called!\r\n    .pipe(jshint)\r\n    // adding a step with an argument\r\n    .pipe(jshint.reporter, 'jshint-stylish');\r\n \r\n// this is OK, because lazypipes are immutable\r\n// jsHintTasks will _not_ be affected by the addition.\r\nvar jsTasks = jsHintTasks\r\n    .pipe(gulp.dest, 'build/js');\r\n \r\n// Create another pipe\r\nvar cssTasks = lazypipe()\r\n    .pipe(recess, recessConfig)\r\n    .pipe(less)\r\n    .pipe(autoprefixer);\r\n\r\n\r\n// now using the lazypipes\r\ngulp.task('jsHint', function() {\r\n    gulp.src('js/**/*.js').pipe(jsHintTasks());\r\n});\r\n\r\ngulp.task('build', function() {\r\n    // for example only!\r\n    return gulp.src('js/**/*.js').pipe(jsTasks());\r\n});\r\n\r\ngulp.task('default', ['build'], function() {\r\n\t// using gulp-watch\r\n\twatch('js/**/*.js').pipe(jsTasks());\r\n});\r\n```\r\n\r\nYou can combine lazypipes in various ways:\r\n\r\n```js\r\n// streamA -> streamB\r\nvar foo = lazypipe().pipe(streamA).pipe(streamB);\r\n\r\n// streamA -> streamB -> streamC\r\nvar bar = foo.pipe(streamC);\r\n\r\n// streamD -> streamA -> streamB -> streamE\r\nvar baz = lazypipe().pipe(streamD).pipe(foo).pipe(streamE);\r\n\r\n```\r\n\r\n### Using with more complex function arguments (such as [gulp-if](https://github.com/robrich/gulp-if))\r\n\r\nLazypipe assumes that all function parameters are static, gulp-if arguments need to be instantiated inside each lazypipe.  This difference can be easily solved by passing a function on the lazypipe step\r\n\r\n```js\r\nvar gulpif = require('gulp-if');\r\nvar jshint = require('gulp-jshint');\r\nvar uglify = require('gulp-uglify');\r\nvar concat = require('gulp-concat');\r\n\r\nvar compressing = false;\r\n\r\nvar jsChannel = lazypipe()\r\n  // adding a pipeline step\r\n  .pipe(jshint) // notice the stream function has not been called!\r\n  .pipe(jshint.reporter)\r\n  // adding a step with an argument\r\n  .pipe(jshint.reporter, 'fail')\r\n  // adding a step with multiple arguments\r\n  .pipe(concat, 'bundle.js', {newLine: ';'})\r\n  // you can't say: .pipe(gulpif, compressing, uglify)\r\n  // because uglify needs to be instantiated separately in each lazypipe instance\r\n  // you can say this instead:\r\n  .pipe(function () {\r\n    return gulpif(compressing, uglify());\r\n  });\r\n  // why does this work? lazypipe calls the function, passing in the no arguments to it,\r\n  // it instantiates a new gulp-if pipe and returns it to lazypipe.\r\n\r\ngulp.task('scripts', function () {\r\n  return gulp.src(paths.scripts.src)\r\n    .pipe(jsChannel())\r\n    .pipe(gulp.dest(paths.scripts.dest));\r\n});\r\n```\r\n\r\n[source](https://github.com/robrich/gulp-if/issues/32)\r\n\r\n\r\n## API\r\n\r\n### `lazypipe()`\r\n\r\nInitializes a lazypipe.  Returns a function that can be used to create the pipeline.  The returned function has a function (`pipe`) which can be used to create new lazypipes with an additional step.\r\n\r\n### `lazypipe().pipe(fn[, arg1[, arg2[, ...]]])`\r\n\r\nCreates a new lazy pipeline with all the previous steps, and the new step added to the end.  Returns the new lazypipe.\r\n\r\n* `fn` - a stream creation function to call when the pipeline is created later.  You can either provide existing functions (such as gulp plugins), or provide your own custom functions if you want to manipulate the stream before creation.\r\n* `arg1, arg2, ...` - Any remaining arguments are saved and passed into `fn` when the pipeline is created.\r\n\r\nThe arguments allows you to pass in configuration arguments when the pipeline is created, like this:\r\n\r\n```js\r\nvar pipeline = lazypipe().pipe(jsHint, jsHintOptions);\r\n\r\n// now, when gulp.src().pipe(pipeline()) is called later, it's as if you did:\r\ngulp.src().pipe(jsHint(jsHintOptions));\r\n```\r\n\r\n### `lazypipe()()`  *\"build\"*\r\n\r\nCalling the result of `pipe()` as a function builds the pipeline at that time.  This can be used multiple times, and can even be called if the lazypipe was used to create different pipelines.\r\n\r\nIt returns a stream created using `stream-combiner`, where all the internal steps are processed sequentially, and the final result is passed on.\r\n\r\n## Help Support This Project\r\n\r\nIf you'd like to support this and other OverZealous Creations (Phil DeJarnett) projects, [donate via Gratipay][gratipay-url]!\r\n\r\n[![Support via Gratipay][gratipay-image]][gratipay-url]\r\n\r\n\r\n## LICENSE\r\n\r\n[MIT License](http://en.wikipedia.org/wiki/MIT_License)\r\n\r\n[npm-url]: https://npmjs.org/package/lazypipe\r\n[npm-image]: https://badge.fury.io/js/lazypipe.png\r\n\r\n[travis-url]: http://travis-ci.org/OverZealous/lazypipe\r\n[travis-image]: https://secure.travis-ci.org/OverZealous/lazypipe.png?branch=master\r\n\r\n\r\n[gratipay-url]: https://www.gratipay.com/OverZealous/\r\n[gratipay-image]: https://img.shields.io/gratipay/OverZealous.svg\r\n",
  "readmeFilename": "README.md",
  "_id": "lazypipe@0.2.4",
  "_from": "lazypipe@^0.2.4"
}
